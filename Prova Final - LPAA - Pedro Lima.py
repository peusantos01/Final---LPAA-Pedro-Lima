# -*- coding: utf-8 -*-
"""Olá, este é o Colaboratory

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/notebooks/intro.ipynb
"""

import pandas as pd
#carregando os dados do arquivo CSV e separando colunas
BTC = pd.read_csv("/Dados Históricos - Bitcoin.csv", sep = ",")
ETH = pd.read_csv("/Dados Históricos - Ethereum.csv", sep = ",")
QQQ = pd.read_csv("/QQQ - Histórico.csv", sep = ",")
#alterando coluna Var
BTC['Var%'] = BTC['Var%'].apply(lambda x: (float(x.split('%')[0].replace(',', '.')))/100)
ETH['Var%'] = ETH['Var%'].apply(lambda x: (float(x.split('%')[0].replace(',', '.')))/100)
QQQ['Var%'] = QQQ['Var%'].apply(lambda x: (float(x.split('%')[0].replace(',', '.')))/100)
#alterando Vol
def convert_to_float(value):
    multipliers = {'K': 1e3, 'M': 1e6, 'B': 1e9}
    if value[-1] in multipliers:
        return float(value[:-1]) * multipliers[value[-1]]
    else:
        return float(value)
BTC['Vol.'] = BTC['Vol.'].apply(lambda x: convert_to_float(x.replace(',', '.')))
ETH['Vol.'] = ETH['Vol.'].apply(lambda x: convert_to_float(x.replace(',', '.')))
QQQ['Vol.'] = QQQ['Vol.'].apply(lambda x: convert_to_float(x.replace(',', '.')))

#alterando outras colunas
def format_number(num_str):
    num_str = num_str.replace('.', '')  # Remover pontos extras
    num_str = num_str.replace(',', '.')  # Substituir vírgula por ponto
    return num_str
#aplicando a função para formatar os números nas colunas necessárias
BTC['Último'] = BTC['Último'].apply(format_number).astype(float)
BTC['Abertura'] = BTC['Abertura'].apply(format_number).astype(float)
BTC['Máxima'] = BTC['Máxima'].apply(format_number).astype(float)
BTC['Mínima'] = BTC['Mínima'].apply(format_number).astype(float)
ETH['Último'] = ETH['Último'].apply(format_number).astype(float)
ETH['Abertura'] = ETH['Abertura'].apply(format_number).astype(float)
ETH['Máxima'] = ETH['Máxima'].apply(format_number).astype(float)
ETH['Mínima'] = ETH['Mínima'].apply(format_number).astype(float)
QQQ['Último'] = QQQ['Último'].apply(format_number).astype(float)
QQQ['Abertura'] = QQQ['Abertura'].apply(format_number).astype(float)
QQQ['Máxima'] = QQQ['Máxima'].apply(format_number).astype(float)
QQQ['Mínima'] = QQQ['Mínima'].apply(format_number).astype(float)


#convertendo as colunas de datas para o formato datetime
BTC['Data'] = pd.to_datetime(BTC['Data'])
ETH['Data'] = pd.to_datetime(ETH['Data'])
QQQ['Data'] = pd.to_datetime(QQQ['Data'])

#redefinir o índice dos DataFrames para conseguir normalizar os dados:
BTC.reset_index(drop=True, inplace=True)
ETH.reset_index(drop=True, inplace=True)
QQQ.reset_index(drop=True, inplace=True)

#normalizando dados (nao consegui normalizar com a equação sugerida de jeito nenhum. tentei de diversas formas e nao funcionou)
#logo,  parti para normalização dos dados para a data de início (D0) sem usar o índice.

for coluna in BTC.columns[1:]:  # aqui vai começar da segunda coluna para evitar a coluna "Data", que estava gerando erro de truediv, mas esse cod. resolveu
    BTC[coluna] = (BTC[coluna] / BTC[coluna].iloc[0]) * 100

for coluna in ETH.columns[1:]:
    ETH[coluna] = (ETH[coluna] / ETH[coluna].iloc[0]) * 100

for coluna in QQQ.columns[1:]:
    QQQ[coluna] = (QQQ[coluna] / QQQ[coluna].iloc[0]) * 100


#adicionando uma coluna identificando qual o ativo.
BTC['Ativo'] = 'Bitcoin'
ETH['Ativo'] = 'Ethereum'
QQQ['Ativo'] = 'QQQ'
#unindo datasets em um unico dataframe a fim de realizar comparações
df = pd.concat([BTC, ETH, QQQ])
#filtrando os dados para incluir apenas os dias úteis, conforme solicitado na atividade
df = df[df['Data'].dt.dayofweek < 5]

#selecionando apenas as colunas numéricas (exceto a coluna "Data")
numeric_columns = df.select_dtypes(include=['float64', 'int64']).columns

#calculando os retornos diários para cada ativo
df['Retornos Diários'] = df.groupby('Ativo')['Último'].pct_change()

#removendo a primeira linha (NaN) de cada ativo
df.dropna(subset=['Retornos Diários'], inplace=True)

import numpy as np
#função para calcular os parâmetros de um determinado ativo
def calcular_parametros(df, ativo):
    #filtrar o DataFrame apenas para o ativo específico
    df_ativo = df[df['Ativo'] == ativo]

    #1 - média de retornos anual
    media_retornos_anual = df_ativo['Retornos Diários'].mean() * 252

    #2 - variância anual
    variancia_anual = df_ativo['Retornos Diários'].var() * 252

    #3 - desvio padrão anual
    desvio_padrao_anual = df_ativo['Retornos Diários'].std() * np.sqrt(252)

    #4 - módulo da amplitude entre máxima e mínima diária e anual
    amplitude_diaria = df_ativo['Máxima'] - df_ativo['Mínima']
    amplitude_anual = amplitude_diaria.mean() * 252

    #5 - módulo da amplitude entre abertura e fechamento diário e anual
    amplitude_abertura_fechamento_diaria = abs(df_ativo['Abertura'] - df_ativo['Último'])
    amplitude_abertura_fechamento_anual = amplitude_abertura_fechamento_diaria.mean() * 252

    #6 - média de variação entre máxima e mínima diária
    media_variacao_maxima_minima_diaria = amplitude_diaria.mean()

    #7 - média de variação entre abertura e fechamento diária
    media_variacao_abertura_fechamento_diaria = amplitude_abertura_fechamento_diaria.mean()

    #8 - retorno acumulado total
    retorno_acumulado_total = (df_ativo['Retornos Diários'] + 1).prod() - 1

    #9 - retorno acumulado nos últimos 12 meses
    retorno_acumulado_12_meses = (df_ativo['Retornos Diários'].tail(252).add(1).prod() - 1) * 100

    #10 - retorno ano a ano
    retorno_ano_a_ano = df_ativo.groupby(df_ativo['Data'].dt.year)['Retornos Diários'].prod() - 1

    #11 - correlação entre os ativos
    correlacao = df_ativo.pivot_table(index='Data', columns='Ativo', values='Retornos Diários').corr()
    correlacao = correlacao.mask(np.eye(correlacao.shape[0], dtype=bool)).stack()

    #12 - correlação com uma janela móvel de 45 dias
    correlacao_janela_movel = df_ativo.groupby('Ativo')['Retornos Diários'].rolling(window=45).corr().unstack()

    #retornando os resultados como um dicionário
    resultados = {
        'Média de Retornos Anual': media_retornos_anual,
        'Variância Anual': variancia_anual,
        'Desvio Padrão Anual': desvio_padrao_anual,
        'Módulo da Amplitude entre Máxima e Mínima (Anual)': amplitude_anual,
        'Módulo da Amplitude entre Abertura e Fechamento (Anual)': amplitude_abertura_fechamento_anual,
        'Média de Variação entre Máxima e Mínima Diária': media_variacao_maxima_minima_diaria,
        'Média de Variação entre Abertura e Fechamento Diária': media_variacao_abertura_fechamento_diaria,
        'Retorno Acumulado Total': retorno_acumulado_total,
        'Retorno Acumulado nos Últimos 12 Meses': retorno_acumulado_12_meses,
        'Retorno Ano a Ano': retorno_ano_a_ano,
        'Correlação entre os Ativos': correlacao,
        'Correlação com Janela Móvel de 45 dias': correlacao_janela_movel
    }

    return resultados

    #lista dos ativos
ativos = ['Bitcoin', 'Ethereum', 'QQQ']

#calculando para cada ativo
for ativo in ativos:
    resultados = calcular_parametros(df, ativo)
    print(f"Resultados para o ativo '{ativo}':")
    for parametro, valor in resultados.items():
        print(f"{parametro}:")
        print(valor)

#5 função para calcular os gaps e sua média por ano para um determinado ativo
def calcular_gaps(df_ativo):
    #calculando os gaps
    df_ativo['Gap'] = df_ativo['Abertura'].shift(-1) - df_ativo['Último']

    #contando quantas vezes houve gap em cada ano
    quantidade_gaps_por_ano = df_ativo.groupby('Ano')['Gap'].apply(lambda x: x.count())

    #calculando a média dos gaps por ano
    media_gaps_por_ano = df_ativo.groupby('Ano')['Gap'].mean()

    return quantidade_gaps_por_ano, media_gaps_por_ano

#lista dos ativos
ativos = ['Bitcoin', 'Ethereum', 'QQQ']

#calculando para cada ativo
for ativo in ativos:
    df_ativo = df[df['Ativo'] == ativo]
    df_ativo['Ano'] = df_ativo['Data'].dt.year  # Adicionando a coluna 'Ano'
    quantidade_gaps_por_ano, media_gaps_por_ano = calcular_gaps(df_ativo)

    #exibindo resultados para o ativo atual
    print(f"Ativo: {ativo}")
    print("Quantidade de Gaps por Ano:")
    print(quantidade_gaps_por_ano)
    print("\nMédia dos Gaps por Ano:")
    print(media_gaps_por_ano)
    print("\n")

#7 plotando os gráficos das correlações entre os ativos
#calculando a correlação entre os ativos fora da função (precisei fazer isso para buscar novamente a variavel fora da funcao def)
import matplotlib.pyplot as plt

correlacao = df.pivot_table(index='Data', columns='Ativo', values='Retornos Diários').corr()
correlacao = correlacao.mask(np.eye(correlacao.shape[0], dtype=bool)).stack()

plt.figure(figsize=(12, 8))

#criando um subplot para cada par de ativos
for i, ativo1 in enumerate(ativos):
    for j, ativo2 in enumerate(ativos):
        if i != j:
            plt.subplot(len(ativos), len(ativos), i * len(ativos) + j + 1)
            sns.scatterplot(data=[correlacao.xs(ativo1, level=0)[ativo2]], color='b')
            plt.title(f'Correlação entre {ativo1} e {ativo2}')

plt.tight_layout()
plt.show()

#8 plotando gráficos normalizados e drawdown
plt.figure(figsize=(12, 8))

#loop sobre cada ativo
for i, ativo in enumerate(ativos, start=1):
    plt.subplot(len(ativos), 1, i)
    plt.plot(df[df['Ativo'] == ativo]['Data'], df[df['Ativo'] == ativo]['Último'], label=ativo)
    plt.title(f'Gráfico Normalizado de {ativo}')
    plt.ylabel('Preço')
    plt.xlabel('Data')
    plt.legend()

plt.tight_layout()
plt.show()

#9 plotando os gráficos normalizados por ano
plt.figure(figsize=(12, 8))

#loop sobre cada ativo
for ativo in ativos:
    #criando uma nova coluna 'Ano' para o ano de cada entrada
    df[f'Ano_{ativo}'] = df[df['Ativo'] == ativo]['Data'].dt.year

    #loop sobre cada ano único para o ativo atual
    for year in df[f'Ano_{ativo}'].unique():
        #filtrar os dados para o ano atual do ativo
        data_year = df[(df['Ativo'] == ativo) & (df[f'Ano_{ativo}'] == year)]

        #verificar se há dados para o ano atual
        if not data_year.empty:
            #calcular os dias desde o início do ano para normalizar os dados
            data_year['Dias_Desde_Inicio_Do_Ano'] = (data_year['Data'] - data_year['Data'].iloc[0]).dt.days

            #plot dos dados normalizados para o ano atual do ativo
            plt.plot(data_year['Dias_Desde_Inicio_Do_Ano'], data_year['Último'], label=f"{ativo} - {year}")

plt.title('Gráfico Normalizado por Ano')
plt.ylabel('Preço')
plt.xlabel('Dias desde o início do ano')
plt.legend()
plt.show()

#10 plotando do histograma dos retornos de todos os ativos
plt.figure(figsize=(12, 8))

#loop sobre cada ativo
for ativo in ativos:
    plt.hist(df[df['Ativo'] == ativo]['Retornos Diários'], bins=20, alpha=0.5, label=ativo)

plt.title('Histograma dos Retornos de Todos os Ativos')
plt.xlabel('Retornos Diários')
plt.ylabel('Frequência')
plt.legend()
plt.show()

#partindo agora para tabela comparativa:

def calcular_drawdown_maximo(series):
    cum_ret = (1 + series).cumprod()
    max_drawdown = (cum_ret / cum_ret.cummax() - 1).min()
    return max_drawdown

#lista para armazenar os resultados
resultados = []

#loop sobre cada ativo
for ativo in ativos:
    #filtrar o DataFrame para o ativo atual
    df_ativo = df[df['Ativo'] == ativo]

    #inicializando os resultados para o ativo atual
    resultados_ativo = {
        'Ativo': ativo,
        'Drawdown Máximo por Ano': [],
        'Retorno por Ano': [],
        'Desvio Padrão por Ano': [],
        'Drawdown Máximo da Série Histórica': 0
    }

    #calculando o drawdown máximo por ano
    drawdown_maximo_por_ano = df_ativo.groupby(df_ativo['Data'].dt.year)['Retornos Diários'].apply(calcular_drawdown_maximo)
    resultados_ativo['Drawdown Máximo por Ano'] = drawdown_maximo_por_ano

    #calcular o retorno por ano
    retorno_por_ano = (df_ativo.groupby(df_ativo['Data'].dt.year)['Retornos Diários'].prod() - 1) * 100
    resultados_ativo['Retorno por Ano'] = retorno_por_ano

    #calcula o desvio padrão por ano
    desvio_padrao_por_ano = df_ativo.groupby(df_ativo['Data'].dt.year)['Retornos Diários'].std() * np.sqrt(252) * 100
    resultados_ativo['Desvio Padrão por Ano'] = desvio_padrao_por_ano

    #Calcula o drawdown máximo da série histórica
    drawdown_maximo_serie = calcular_drawdown_maximo(df_ativo['Retornos Diários']) * 100
    resultados_ativo['Drawdown Máximo da Série Histórica'] = drawdown_maximo_serie

    #adiciona os resultados para o ativo atual à lista de resultados
    resultados.append(resultados_ativo)

#criando tabela a partir de um DataFrame de acordo com os resultados
tabela_comparativa = pd.DataFrame(resultados)

#exibindo a tabela comparativa
print(tabela_comparativa)